#compdef bosh

_check_login()
{
  # check if logged to a director, elsewhere exit with error message
  _li=$(bosh env --json|jq -r -S '.Tables[].Rows[].user' 2>/dev/null)
  [ $? -ne 0 ] || [[ "$_li" == "(not logged in)" ]] && return 1
  return 0
}

_bosh_main_functions()
{
  available=$*
  local -a _arg
  if [[ "$available" == "" ]]
  then  
    IFS=$'\n' _arg=($(bosh help | \
      tr -s "[:space:]" | \
      sed -e "1,/^Available commands:/d" \
          -e "s/[[:space:]]https:\/\/bosh\.io.*$//" \
          -e "s/^[[:space:]]*\([^[:space:]]*\)[[:space:]]*\(.*\)/\1:\2/"))
  else
    for i in ${available}
    do
      IFS=$'\n' _arg+=$(bosh help | \
      tr -s "[:space:]" | \
      sed -e "1,/^Available commands:/d" \
          -e "s/[[:space:]]https:\/\/bosh\.io.*$//" \
          -e "s/^[[:space:]]*\([^[:space:]]*\)[[:space:]]*\(.*\)/\1:\2/" | \
      grep "^$i")
    done
  fi  

  
  _describe -t commands "bosh command" _arg
  return
}

_list_deployments()
{
  # this is a function used in many subcommands, offering the deployment list
  ret=0
  [ "$words[2]" != "-d" ] && compadd -Q "$@" -- "-d" && ret=1
  if [ $ret -eq 0 ]
  then
    if [[ -z ${words[3]} ]]
    then
      local -a _list
      _list=(
        $(bosh deployments --json | jq -r ".Tables[].Rows[].name")
      )
      _describe -t commands "bosh list deployments" _list
      ret=1
    fi
  fi
  return $ret
}

_delete-deployment()
{
  _list_deployments
  [ $? -eq 1 ] && return
}

_delete-release()
{
  local -a _releases_list
  _releases_list=(
  $(bosh releases --json| jq -r '.Tables[].Rows[]|.name+"/"+.version')
  )

  _describe -t commands "bosh delete-release" _releases_list
  return
}

_ssh()
{
  _list_deployments 
  [ $? -eq 1 ] && return
  local -a _vms_list
  IFS=$'\n' _vms_list=(
    $(bosh -d $words[3] vms --json| jq -r '.Tables[].Rows[]|.instance+":"+.ips')
    )
  _describe -t commands "bosh ssh" _vms_list
  return
}

_vms()
{
  _list_deployments
  [ $? -eq 1 ] && return
}

_add_blob()
{
  # allow only one file
  [ ! -z $words[2] ] && _files
  return
}

_create-release()
{
  ret=0

  local -a _arg

  _arg=(
  "--dir=":"Release directory path if not current working directory (default: .)"
  "--name=":"Custom release name"
  "--version=":"Custom release version (e.g.: 1.0.0, 1.0-beta.2+dev.10)"
  "--timestamp-version":"Create release with the timestamp as the dev version (e.g.: 1+dev.TIMESTAMP)"
  "--final":"Make it a final release"
  "--tarball=":"Create release tarball at path (e.g. /tmp/release.tgz)"
  "--force":"Ignore Git dirty state check"
  "":"None"
  )
  _describe -t create-release "bosh create-release" _arg -S ''
  return $ret
}

_bosh()
{
  _arguments '*:: :->command'
  local -a no_subcommand=(
    stemcells
    deployments
    log-in
    log-out
    releases
    tasks
    blobs
    reset-release
    sync-blobs
  )
  if (( CURRENT==1 ))
  then
    available=""
    _check_login
    [ $? -ne 0 ] && available="log-in"
    _bosh_main_functions ${available}
  # launch subcommand if it has one   
  elif [[ -z $(echo "${no_subcommand[@]:0}"|grep -o ${words[1]}) ]]
  then
    eval _${words[1]}
  fi
  return

}

_bosh "$@"